\textbf{Метод 3 --- Метод простых итераций/метод Зейделя}\\

\textbf{Задание}

Реализовать метод простых итераций и метод Зейделя в виде программ, задавая в качестве входных данных матрицу системы, вектор правых частей и точность вычислений. Используя разработанное программное обеспечение, решить СЛАУ. Проанализировать количество итераций, необходимое для достижения заданной точности.\\

\textbf{Вариант:} 3

$
\begin{cases}
-23x_1-7x_2+5x_3+2x_4=-26\\
-7x_1-21x_2+4x_3+9x_4=-55\\
9x_1+5x_2-31x_3-8x_4=-58\\
x_2-2x_3+10x_4=-24
\end{cases}
$
\vspace{0.5cm}

\textbf{Описание алгоритма}

При большом числе уравнений прямые методы решения СЛАУ  (за исключением метода прогонки) становятся труднореализуемыми на ЭВМ прежде всего из--за сложности хранения и обработки матриц большой размерности.\\

Методы последовательных приближений, в которых при вычислении последующего приближения решения используются предыдущие, уже известные приближенные решения, называются \textit{итерационными}.\\

Рассмотрим СЛАУ:\\

$
\begin{cases}
a_{11}x_1+a_{12}x_2+...+a_{1n}x_n=b_1\\
a_{21}x_1+a_{22}x_2+...+a_{2n}x_n=b_2\\
...\\
a_{n1}x_1+a_{n2}x_2+...+a_{nn}x_n=b_n\\
\end{cases}
$\\

с невырожденной матрицей ($det A \neq 0$).\\

Приведем СЛАУ к эквивалентному виду:\\

$
\begin{cases}
x_1=\beta_1+a_{11}x_1+a_{12}x_2+...+a_{1n}x_n\\
x_2=\beta_2+a_{21}x_1+a_{22}x_2+...+a_{2n}x_n\\
...\\
x_n=\beta_n+a_{n1}x_1+a_{n2}x_2+...+a_{nn}x_n\\
\end{cases}
$\\

или в векторно--матричной форме:

$$
x=\beta + \alpha x
$$

$$
x=\begin{pmatrix}
x_1\\
\vdots\\
x_n
\end{pmatrix},
\beta=\begin{pmatrix}
\beta_1\\
\vdots\\
\beta_n
\end{pmatrix},
\alpha=\begin{pmatrix}
a_{11} & \cdots & a_{1n}\\
\vdots & \cdots & \vdots\\
a_{n1} & \cdots & a_{nn}
\end{pmatrix}
$$

Такое приведение может быть выполнено различными способами. Один из них показан ниже.

$$
\beta_i=\frac{b_i}{a_{ii}}; a_{ij}=-\frac{a_{ij}}{a_{ii}}, i,j=\overline{1,n}, i \neq j; a_{ij}=0, i=j, i=\overline{1,n}
$$

\textit{Метод простых итераций сходится к единственному решению СЛАУ при любом начальном приближении $x^{(0)}$, если какая-либо норма матрицы $\alpha$ эквивалентной системы меньше единицы $\| \alpha \| < 1$}\\

Если используется метод Якоби, то достаточным условием сходимости является \textit{диагональное преобладание матрицы $A$}, т.е. $|a_{ii}|>\sum\limits_{j=1,i \neq j}^n|a_{ij}|$ (для каждой строки матрицы $A$ модули элементов, стоящих на главной диагонали, больше суммы модулей недиагональных элементов).\\

Поскольку $\| \alpha \| < 1$ является только достаточным (не необходимым) условием сходимости метода простых итераций, то итерационный процесс может сходиться и в случае, если оно не выполнено. Тогда критерием окончания итераций может служить неравенство $\|x^{(k)}-x^{(k-1)}\| \leq \varepsilon$.\\

\textbf{Метод Зейделя}

Метод простых итераций довольно медленно сходится. Для его ускорения существует \textit{метод Зейделя}, заключающийся в том, что при вычислении компонента $x_i^{k+1}$ вектора неизвестных на $(k+1)$--й итерации используется $x_1^{k+1}, x_2^{k+1}, ..., x_{i-1}^{k+1}$ уже вычисленные на $(k+1)$--й итерации. Значения остальных компонент $x_{i+1}^{k}, x_{i+2}^{k}, ..., x_{n}^{k}$ берутся из предыдущей итерации.\\

$$
x^{k+1}=\beta + Bx^{k+1}+Cx^k
$$\\

где $B$ --- нижняя треугольная матрица с диагональными элементами, равными нулю, а $C$ --- верхняя треугольная матрица с диагональными элементами, отличными от нуля, $\alpha = B + C$.\\

\textbf{Реализация}

\begin{lstlisting}
int TSolve::ToSolveBySimpleIterations() {
    TFRFF* tmpRead = _readFromFile(pathFrom, SimpleIter);
    if (tmpRead == NULL)
        return -1;
    _matrA.SetLink(tmpRead->matr);
    _vecB.SetLink(tmpRead->vec);
    if (abs(_matrA.GetNorm()) >= 1.0) {
        cerr << "Error!!!" << endl;
        return -1;
    }
    log.open("solve1SimpleIter.log", ofstream::out);
    log << "|Method Simple Iterations| by Alexander Bales 80-308" << endl << endl;
    log << "|A| = " << _matrA.GetNorm() << endl << endl;
    _vecX = _vecB;    
    TVector vecRes = _vecX + (_matrA * _vecX.Rotate()).Rotate();    
    _vecB.Print(log, "B");    
    _matrA.Print(log, "A");    
    double tmp = abs(_matrA.GetNorm());
    double eps_k = 1.0 * tmp / (1.0 - tmp) * (vecRes - _vecX).GetNorm();	
    for (int i = 1; eps_k > eps; ++i) {
        _vecX = vecRes;
        log << "x_" << i - 1 << " = (";
        _vecX.Print(log);
        log << "); ";	    
        vecRes = _vecB + (_matrA * _vecX.Rotate()).Rotate();
        log << "x_" << i << " = (";
        vecRes.Print(log);
        log << "); ";
        eps_k = tmp / (1.0 - tmp) * (vecRes - _vecX).GetNorm();
        log << "eps(" << i << ") = " << eps_k << endl;
    }    
    for (int i = 0; i < vecRes.GetSize(); ++i) {
        output << vecRes[i] << endl;
    }
    _writeToFile(pathTo);
    _clear();  
    delete tmpRead; 
    return 0;
} 
\end{lstlisting}
\vspace{0.5cm}

\textbf{Тестирование}\\

\textbf{Входной файл}
\begin{verbatim}
4
-23 -7 5 2 -26
-7 -21 4 9 -55
9 5 -31 -8 -58
0 1 -2 10 -24
\end{verbatim}

\textbf{Выходной файл}
\begin{verbatim}
solve1SimpleIter.log:
|Method Simple Iterations| by Alexander Bales 80-308

|A| = 0.952

Vector B = (1.13, 2.62, 1.87, -2.4)

Matrix A:
0 -0.304 0.217 0.087 
-0.333 0 0.19 0.429 
0.29 0.161 0 -0.258 
-0 -0.1 0.2 0 

x_0 = (0.531 1.57 3.24 -2.29); x_1 = (1.16 2.08 2.87 -1.91); eps(1) = 37.7
x_1 = (1.16 2.08 2.87 -1.91); x_2 = (0.955 1.96 3.04 -2.03); eps(2) = 12.2
x_2 = (0.955 1.96 3.04 -2.03); x_3 = (1.02 2.01 2.99 -1.99); eps(3) = 3.94
x_3 = (1.02 2.01 2.99 -1.99); x_4 = (0.997 2 3 -2); eps(4) = 1.13
x_4 = (0.997 2 3 -2); x_5 = (1 2 3 -2); eps(5) = 0.31
x_5 = (1 2 3 -2); x_6 = (1 2 3 -2); eps(6) = 0.0857
x_6 = (1 2 3 -2); x_7 = (1 2 3 -2); eps(7) = 0.0218
x_7 = (1 2 3 -2); x_8 = (1 2 3 -2); eps(8) = 0.0059

solve1Zeydel.log:
|Method Zeydel| by Alexander Bales 80-308

Vector B = (1.13, 2.62, 1.87, -2.4)

Matrix A:
0 -0.304 0.217 0.087 
-0.333 0 0.19 0.429 
0.29 0.161 0 -0.258 
-0 -0.1 0.2 0 

x_0 = (0.531 1.77 2.93 -1.99); x_1 = (1.06 1.97 3.01 -2); eps(1) = 136
x_1 = (1.06 1.97 3.01 -2); x_2 = (1.01 2 3 -2); eps(2) = 14.2
x_2 = (1.01 2 3 -2); x_3 = (1 2 3 -2); eps(3) = 2.21
x_3 = (1 2 3 -2); x_4 = (1 2 3 -2); eps(4) = 0.171
x_4 = (1 2 3 -2); x_5 = (1 2 3 -2); eps(5) = 0.0257
x_5 = (1 2 3 -2); x_6 = (1 2 3 -2); eps(6) = 0.00353

res:
Matrix A:
0 -0.304 0.217 0.087 
-0.333 0 0.19 0.429 
0.29 0.161 0 -0.258 
-0 -0.1 0.2 0 

Vector B = (1.13, 2.62, 1.87, -2.4)

Vector X = (1, 2, 3, -2)
\end{verbatim}

\pagebreak
